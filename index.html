<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>400m Rundkurs – Pace Vergleich</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; background:#0b1020; color:#eef2ff; }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 18px; }
    h1 { font-size: 20px; margin: 0 0 12px; }
    .panel { display:flex; gap:12px; flex-wrap:wrap; align-items:flex-end; margin: 10px 0 16px; }
    .card { background:#121a33; border:1px solid #22305f; border-radius:12px; padding:12px; }
    label { display:block; font-size:12px; opacity:.9; margin-bottom:6px; }
    input { width: 120px; padding:8px 10px; border-radius:10px; border:1px solid #2b3b76; background:#0e1530; color:#eef2ff; }
    button { padding:10px 14px; border-radius:12px; border:1px solid #2b3b76; background:#2b64ff; color:white; cursor:pointer; font-weight:600; }
    button.secondary { background:#111a34; }
    button:disabled { opacity:.6; cursor:not-allowed; }
    .row { display:flex; gap:12px; flex-wrap:wrap; }
    .info { font-size:13px; line-height:1.4; opacity:.95; }
    .mono { font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .stage { background:#0a0f22; border:1px solid #22305f; border-radius:16px; padding:12px; }
    svg { width: 100%; height: auto; display:block; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>400m Rundkurs – Pace Vergleich</h1>

    <div class="panel">
      <div id="runnersList" style="display:flex; gap:12px; align-items:flex-end;">
        <div class="card">
          <label for="pace1">Läufer 1 (min/km)</label>
          <input id="pace1" class="paceInput" value="5:00" />
        </div>
        <div class="card">
          <label for="pace2">Läufer 2 (min/km)</label>
          <input id="pace2" class="paceInput" value="4:00" />
        </div>
      </div>

      <div class="card">
        <label for="numRunners">Anzahl Läufer</label>
        <select id="numRunners">
          <option value="2" selected>2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="5">5</option>
          <option value="6">6</option>
          <option value="7">7</option>
          <option value="8">8</option>
        </select>
      </div>

      <div class="card">
        <label for="timeScale">Geschwindigkeit</label>
        <select id="timeScale">
          <option value="0.5">0.5×</option>
          <option value="1" selected>1×</option>
          <option value="2">2×</option>
          <option value="4">4×</option>
          <option value="8">8×</option>
        </select>
      </div>

      <button id="startBtn">Start</button>
      <button id="pauseBtn" class="secondary" disabled>Pause</button>
      <button id="resetBtn" class="secondary">Reset</button>
    </div>

    <div class="row">
      <div class="card info" style="flex:1; min-width:260px;">
        <div><strong>Rundenzeiten (400m)</strong></div>
        <div class="mono" id="times">–</div>
        <div style="height:10px"></div>
        <div><strong>Abstand auf der Bahn</strong></div>
        <div class="mono" id="gap">–</div>
      </div>

      <div class="stage" style="flex:3; min-width:360px;">
        <svg viewBox="0 0 1000 520" aria-label="400m Bahn">
          <rect x="0" y="0" width="1000" height="520" fill="#070b17" rx="18"></rect>
          <defs>
            <pattern id="tartan" patternUnits="userSpaceOnUse" width="24" height="24">
              <rect width="24" height="24" fill="#9b1e2a"></rect>
              <rect x="0" y="8" width="24" height="2" fill="#7c2238" opacity="0.9"></rect>
              <rect x="8" y="0" width="2" height="24" fill="#7c2238" opacity="0.9"></rect>
              <rect x="0" y="12" width="24" height="1" fill="#ffd24d" opacity="0.35"></rect>
              <rect x="12" y="0" width="1" height="24" fill="#ffd24d" opacity="0.35"></rect>
              <rect x="0" y="4" width="24" height="1" fill="#2b5fa8" opacity="0.25"></rect>
              <rect x="4" y="0" width="1" height="24" fill="#2b5fa8" opacity="0.25"></rect>
            </pattern>
          </defs>

          <!-- Parameter der Bahn (nur als Kommentar):
               Außen:  Gerade von x=260..740 bei y=90/430, Kurvenradius=170
               Innen:  Gerade von x=330..670 bei y=150/370, Kurvenradius=110
          -->

          <!-- Infield (Rasen) = inneres Oval -->
          <path id="infield"
            d="M 330 150
               L 670 150
               A 110 110 0 0 1 670 370
               L 330 370
               A 110 110 0 0 1 330 150
               Z"
            fill="#1f7a3a" opacity="0.96"></path>

          <!-- Tartan-Ring (außen - innen), korrektes Stadionoval -->
          <path id="trackRing" fill-rule="evenodd"
            d="M 260 90
               L 740 90
               A 170 170 0 0 1 740 430
               L 260 430
               A 170 170 0 0 1 260 90
               Z
               M 330 150
               L 670 150
               A 110 110 0 0 1 670 370
               L 330 370
               A 110 110 0 0 1 330 150
               Z"
            fill="url(#tartan)" opacity="0.98"></path>

          <!-- Innen-/Außenkante -->
          <path d="M 260 90 L 740 90 A 170 170 0 0 1 740 430 L 260 430 A 170 170 0 0 1 260 90 Z"
                fill="none" stroke="#ffffff" stroke-width="3" opacity="0.30"></path>
          <path d="M 330 150 L 670 150 A 110 110 0 0 1 670 370 L 330 370 A 110 110 0 0 1 330 150 Z"
                fill="none" stroke="#ffffff" stroke-width="3" opacity="0.55"></path>

          <!-- Bahnlinien (mehrere Ovale zwischen innen und außen) -->
          <g opacity="0.75" fill="none" stroke="#ffffff" stroke-width="2">
            <path d="M 318 140 L 682 140 A 120 120 0 0 1 682 380 L 318 380 A 120 120 0 0 1 318 140 Z"></path>
            <path d="M 306 130 L 694 130 A 130 130 0 0 1 694 390 L 306 390 A 130 130 0 0 1 306 130 Z"></path>
            <path d="M 294 120 L 706 120 A 140 140 0 0 1 706 400 L 294 400 A 140 140 0 0 1 294 120 Z"></path>
            <path d="M 282 110 L 718 110 A 150 150 0 0 1 718 410 L 282 410 A 150 150 0 0 1 282 110 Z"></path>
          </g>

           <!-- Unsichtbare Laufwege für Läufer (beide auf derselben Bahn) -->
          <path id="lanePathA"
            d="M 306 130
               L 694 130
               A 130 130 0 0 1 694 390
               L 306 390
               A 130 130 0 0 1 306 130
               Z"
            fill="none"></path>
           <!-- lanePathB bleibt im SVG zur Referenz, wird aber nicht für die Läufer verwendet -->
           <path id="lanePathB"
            d="M 282 110
              L 718 110
              A 150 150 0 0 1 718 410
              L 282 410
              A 150 150 0 0 1 282 110
              Z"
            fill="none" opacity="0.0"></path>

          <!-- Start/Ziel Linie (unten auf der Geraden) - verschoben weiter rechts wie bei echter Bahn -->
          <line x1="660" y1="430" x2="660" y2="370" stroke="#ffffff" stroke-width="5" opacity="0.95"></line>
          <text x="672" y="405" fill="#ffffff" font-size="16" opacity="0.95">Start/Ziel</text>

          <!-- Läufer (dynamisch erzeugt) - die statischen Beispiele werden ausgeblendet -->
          <circle id="runnerA" r="10" fill="#7cf7a4" style="display:none"></circle>
          <circle id="runnerB" r="10" fill="#ff7aa2" style="display:none"></circle>

          <!-- Legende -->
          <rect x="18" y="18" width="240" height="66" rx="12" fill="#0b1020" stroke="#22305f"></rect>
          <circle cx="40" cy="46" r="8" fill="#7cf7a4"></circle>
          <text x="56" y="51" fill="#eef2ff" font-size="16">Läufer A</text>
          <circle cx="150" cy="46" r="8" fill="#ff7aa2"></circle>
          <text x="166" y="51" fill="#eef2ff" font-size="16">Läufer B</text>
        </svg>
      </div>
    </div>
  </div>

<script>
  // Pace parsing: "5:00" oder "4:35" oder "5" (min/km)
  function parsePaceToSecPerKm(str) {
    const s = (str || "").trim().replace(",", ".");
    if (!s) return NaN;
    if (s.includes(":")) {
      const [m, sec] = s.split(":");
      const mm = Number(m);
      const ss = Number(sec || "0");
      if (!Number.isFinite(mm) || !Number.isFinite(ss)) return NaN;
      return mm * 60 + ss;
    }
    const mins = Number(s);
    if (!Number.isFinite(mins)) return NaN;
    return mins * 60;
  }

  function wrap01(x){ x = x % 1; return x < 0 ? x + 1 : x; }

  // pace inputs (will be created/managed dynamically)
  const numRunnersEl = document.getElementById("numRunners");
  function getPaceEls() { return Array.from(document.querySelectorAll(".paceInput")); }
  const startBtn = document.getElementById("startBtn");
  const pauseBtn = document.getElementById("pauseBtn");
  const resetBtn = document.getElementById("resetBtn");
  const timesEl = document.getElementById("times");
  const gapEl = document.getElementById("gap");
  const timeScaleEl = document.getElementById("timeScale");

  const lanePathA = document.getElementById("lanePathA");
  const lanePathB = document.getElementById("lanePathB");

  // Beide Läufer folgen derselben Bahn (lanePathA). lanePathB bleibt nur als Referenz.
  const laneMain = lanePathA;
  const lenMain = laneMain.getTotalLength();

  const LAP_M = 400;

  // Runner state arrays (dynamic)
  let progs = [];
  let vs = [];
  let runnerEls = []; // {circle, label}

  let running = false, paused = false, lastFrame = 0;

  function setPos(circleEl, t01, pathEl, pathLen) {
    const p = pathEl.getPointAtLength(wrap01(t01) * pathLen);
    circleEl.setAttribute("cx", p.x);
    circleEl.setAttribute("cy", p.y);
  }

  // Suche die Position entlang der Bahn, die der Start/Ziel-Linie (x=500,y≈400) am nächsten ist.
  function findClosestRatioToPoint(x, y, path, pathLen) {
    let bestI = 0;
    let bestD = Infinity;
    const step = Math.max(2, Math.floor(pathLen / 800));
    for (let i = 0; i <= pathLen; i += step) {
      const p = path.getPointAtLength(i);
      const dx = p.x - x, dy = p.y - y;
      const d = dx*dx + dy*dy;
      if (d < bestD) { bestD = d; bestI = i; }
    }
    return bestI / pathLen;
  }

  const startRatio = findClosestRatioToPoint(660, 400, laneMain, lenMain);

  function fmtTime(sec){
    const m = Math.floor(sec / 60);
    const s = Math.round(sec - m * 60);
    return `${m}:${String(s).padStart(2,"0")}`;
  }

  const COLORS = ["#7cf7a4","#ff7aa2","#ffd36b","#6fd1ff","#cfa0ff","#ff9f7a","#9be27a","#63d0d8"];

  // Create SVG runner elements (circle + small number label)
  function createSvgRunner(idx) {
    const svg = laneMain.ownerSVGElement || document.querySelector('svg');
    const cir = document.createElementNS('http://www.w3.org/2000/svg','circle');
    cir.setAttribute('r', 10);
    cir.setAttribute('fill', COLORS[idx % COLORS.length]);
    cir.setAttribute('id', `runner_circle_${idx}`);
    const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
    txt.setAttribute('fill','#070b17');
    txt.setAttribute('font-size','12');
    txt.setAttribute('font-weight','700');
    txt.setAttribute('text-anchor','middle');
    txt.setAttribute('dominant-baseline','middle');
    txt.setAttribute('id', `runner_label_${idx}`);
    txt.textContent = String(idx+1);
    svg.appendChild(cir);
    svg.appendChild(txt);
    return {circle: cir, label: txt};
  }

  function removeExtraRunners() {
    runnerEls.forEach(e => {
      if (e.circle && e.circle.parentNode) e.circle.parentNode.removeChild(e.circle);
      if (e.label && e.label.parentNode) e.label.parentNode.removeChild(e.label);
    });
    runnerEls = [];
  }

  function buildRunners(n) {
    removeExtraRunners();
    progs = new Array(n).fill(startRatio);
    vs = new Array(n).fill(0);
    for (let i=0;i<n;i++) runnerEls.push(createSvgRunner(i));
  }

  function recalc() {
    const paceEls = getPaceEls();
    const n = paceEls.length;
    let ok = true;
    for (let i=0;i<n;i++){
      const sec = parsePaceToSecPerKm(paceEls[i].value);
      if (!Number.isFinite(sec) || sec <= 0) { ok = false; break; }
      vs[i] = 1000 / sec;
    }
    if (!ok) {
      timesEl.textContent = "Bitte Pace korrekt eingeben (z.B. 5:00 oder 4:35).";
      return false;
    }
    // Anzeige: nur die ersten zwei Läufer wie bisher, sonst kurze Zusammenfassung
    const lapTimes = vs.map(v => LAP_M / v);
    if (n <= 2) {
      timesEl.textContent = `A: ${fmtTime(lapTimes[0])} pro 400m  |  B: ${fmtTime(lapTimes[1])} pro 400m`;
    } else {
      timesEl.textContent = `Läufer: ${lapTimes.map(t=>fmtTime(t)).join(' | ')}`;
    }
    return true;
  }

  function updateGap() {
    // Bestimme Führenden und Abstände zu allen anderen (entlang Bahn)
    if (progs.length === 0) { gapEl.textContent = '–'; return; }
    // Führender = größter (negative Richtung) Fortschritt relativ zum Start
    // Wir mappe auf [0,1) und wähle den kleinsten wrap distance zum Beginn
    let leader = 0;
    for (let i=1;i<progs.length;i++) if (progs[i] < progs[leader]) leader = i;
    // Zeige Abstände (vorwärts) zum Führenden
    const lines = [];
    for (let i=0;i<progs.length;i++){
      if (i===leader) continue;
      const d = wrap01(progs[leader] - progs[i]); // wieviel der Führende vor dem i ist
      lines.push(`L${leader+1} ± L${i+1}: ${ (d*LAP_M).toFixed(1) } m`);
    }
    gapEl.textContent = lines.length ? `${'Führender: L'+(leader+1)} — ${lines.join('  |  ')}` : 'Gleichauf';
  }

  function reset() {
    running = false; paused = false;
    startBtn.disabled = false;
    pauseBtn.disabled = true;
    pauseBtn.textContent = "Pause";

    // Start/Ziel-Position ermitteln und alle Läufer dort platzieren (mit kleinen Versätzen)
    const n = progs.length || 2;
    for (let i=0;i<n;i++){
      // Keine Versetzung: alle Läufer exakt auf der Startlinie
      progs[i] = wrap01(startRatio);
      const el = runnerEls[i];
      if (el) {
        setPos(el.circle, progs[i], laneMain, lenMain);
        // Label leicht oberhalb der Markierung
        const p = laneMain.getPointAtLength(progs[i]*lenMain);
        el.label.setAttribute('x', p.x);
        el.label.setAttribute('y', p.y);
      }
    }

    timesEl.textContent = "–";
    gapEl.textContent = "–";
  }

  function tick(ts) {
    if (!running) return;

    const dt = (ts - lastFrame) / 1000;
    lastFrame = ts;
    // apply time scale multiplier from UI
    const speedMul = Number(timeScaleEl && timeScaleEl.value) || 1;
    const adjDt = dt * speedMul;

    if (!paused) {
      // Gegen den Uhrzeigersinn: negative Richtung entlang der Parametrisierung
      for (let i=0;i<progs.length;i++){
        progs[i] = wrap01(progs[i] - (vs[i] / LAP_M) * adjDt);
        const el = runnerEls[i];
        if (el) {
          setPos(el.circle, progs[i], laneMain, lenMain);
          const p = laneMain.getPointAtLength(progs[i]*lenMain);
          el.label.setAttribute('x', p.x);
          el.label.setAttribute('y', p.y);
        }
      }
      updateGap();
    }

    requestAnimationFrame(tick);
  }

  startBtn.addEventListener("click", () => {
    if (!recalc()) return;
    running = true; paused = false;
    startBtn.disabled = true;
    pauseBtn.disabled = false;
    pauseBtn.textContent = "Pause";
    lastFrame = performance.now();
    requestAnimationFrame(tick);
  });

  pauseBtn.addEventListener("click", () => {
    if (!running) return;
    paused = !paused;
    pauseBtn.textContent = paused ? "Weiter" : "Pause";
  });

  resetBtn.addEventListener("click", reset);

  // Rebuild UI/runner list when Anzahl geändert
  numRunnersEl.addEventListener('change', ()=>{
    const n = Number(numRunnersEl.value);
    // ensure pace inputs exist
    const list = document.getElementById('runnersList');
    const existing = list.querySelectorAll('.paceInput');
    for (let i=existing.length+1;i<=n;i++){
      const card = document.createElement('div'); card.className='card';
      const lab = document.createElement('label'); lab.setAttribute('for', 'pace'+i); lab.textContent = `Läufer ${i} (min/km)`;
      const inp = document.createElement('input'); inp.id = 'pace'+i; inp.className='paceInput'; inp.value = i<=2 ? (i===1? '5:00':'4:00') : '5:30';
      card.appendChild(lab); card.appendChild(inp);
      list.appendChild(card);
    }
    // if reduced, remove extras
    while (list.querySelectorAll('.paceInput').length > n) {
      const last = list.lastElementChild; list.removeChild(last);
    }
    buildRunners(n);
    // populate vs from input values
    recalc();
    reset();
  });

  // initial: setup runners according to default select
  buildRunners(Number(numRunnersEl.value));
  recalc();
  reset();
</script>
</body>
</html>
